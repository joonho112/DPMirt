---
title: "Quick Start: Your First IRT Model in 5 Minutes"
author: "JoonHo Lee"
date: "`r Sys.Date()`"
description: >
  A hands-on introduction to DPMirt: simulate data, fit Rasch models with
  Normal and DPM priors, visualize results, and extract person ability
  estimates --- all in under five minutes of reading.
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Quick Start: Your First IRT Model in 5 Minutes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
library(DPMirt)
knitr::opts_chunk$set(
  collapse    = TRUE,
  comment     = "#>",
  fig.width   = 7,
  fig.height  = 5,
  fig.align   = "center",
  out.width   = "85%"
)
set.seed(42)

# DPMirt palette (for inline use in this vignette)
pal <- list(
  parametric     = "#56B4E9",
  semiparametric = "#E69F00",
  reference      = "gray50"
)

# Helper: find extdata files in installed package OR source tree
find_extdata <- function(filename) {
  # Try installed package first
  path <- system.file("extdata", filename, package = "DPMirt")
  if (nzchar(path) && file.exists(path)) return(path)
  # Fallback: source tree (during R CMD build / devtools::build_vignettes)
  path2 <- file.path("..", "inst", "extdata", filename)
  if (file.exists(path2)) return(path2)
  ""
}

# Guard: pre-computed MCMC results must exist for eval'd chunks
has_data <- nzchar(find_extdata("vignette_fit_rasch_normal.rds")) &&
  nzchar(find_extdata("vignette_fit_rasch_dpm.rds"))
```

## Overview

This vignette walks you through a complete DPMirt workflow from start to
finish.
By the end you will know how to:

1. **Simulate** IRT response data with `dpmirt_simulate()`.
2. **Fit** a Rasch model under both a Normal prior and a Dirichlet Process
   Mixture (DPM) prior.
3. **Visualize** posterior densities, item parameters, and MCMC diagnostics.
4. **Extract** person ability estimates using posterior mean (PM), constrained
   Bayes (CB), and triple-goal (GR) estimators.

No NIMBLE compilation is required for the simulation or estimation steps
shown here --- we load pre-computed MCMC results so you can follow along
instantly.

## Simulate Data

`dpmirt_simulate()` generates binary response data under a known IRT model.
When the optional **IRTsimrel** package is installed, it uses Empirical
Quadrature Calibration (EQC) to hit a target marginal reliability; otherwise
it falls back to a Paganin-style simulation.

```{r simulate}
sim <- dpmirt_simulate(
  n_persons    = 200,
  n_items      = 25,
  model        = "rasch",
  target_rho   = 0.8,
  latent_shape = "normal",
  seed         = 42
)

str(sim, max.level = 1)
```

The returned `dpmirt_sim` object contains the binary response matrix
(`sim$response`), the true person abilities (`sim$theta`), and the true item
difficulties (`sim$beta`).
You can inspect the simulation with `print()`:

```{r print-sim}
sim
```

Because `dpmirt_simulate()` is pure R, it runs instantly --- no NIMBLE
compilation needed.

## Fit a Rasch Model with a Normal Prior

The main entry point is `dpmirt()`.
Below is the call you would run in an interactive session.
NIMBLE compiles the model on first use, which takes roughly 1--2 minutes;
after that, additional sampling is fast.

```r
# This is the code you would run (takes ~2 minutes for compilation):
fit <- dpmirt(
  sim$response,
  model   = "rasch",
  prior   = "normal",
  niter   = 10000,
  nburnin = 2000,
  seed    = 100
)
```

For this vignette we load a pre-computed result instead:

```{r load-fit-normal, eval = has_data}
fit <- readRDS(find_extdata("vignette_fit_rasch_normal.rds"))
```

## Understanding the Output

A `dpmirt_fit` object stores posterior samples, diagnostics, and model
configuration.
The `print()` method gives a compact overview:

```{r print-fit, eval = has_data}
print(fit)
```

Key fields:

- **Model / Prior / Identification** --- what was specified.
- **MCMC** --- iteration count, burn-in, and thinning.
- **WAIC** --- Watanabe--Akaike information criterion for model comparison.
- **Min ESS** --- minimum effective sample size across items and persons; a
  quick convergence check.
- **Total time** --- wall-clock time for the full pipeline.

For a richer view, call `summary()`:

```{r summary-fit, eval = has_data}
summary(fit)
```

The summary adds item-by-item parameter estimates (posterior mean and SD),
a distributional summary of person abilities, and --- for DPM models ---
cluster and concentration-parameter diagnostics.

## Visualizations

`plot(fit, type = ...)` dispatches to 12 plot types.
If **ggplot2** is installed the package uses it automatically; otherwise
base R graphics are produced.

### Posterior Density of Theta

```{r plot-density, eval = has_data, fig.cap = "Kernel density of the posterior mean theta under a Normal prior."}
plot(fit, type = "density")
```

This shows the kernel density of the $N = 200$ posterior-mean person
abilities.
Under a Normal prior the density is smooth and unimodal by construction.

### Item Difficulty Estimates

```{r plot-items, eval = has_data, fig.cap = "Item difficulty estimates with +/- 2 posterior SD error bars."}
plot(fit, type = "items")
```

Each point is the posterior mean of $\beta_j$; error bars span
$\pm 2$ posterior standard deviations.
Items are ordered from easiest (most negative) to hardest.

### MCMC Trace

```{r plot-trace, eval = has_data, fig.cap = "Log-likelihood trace plot. A stationary trace suggests convergence."}
plot(fit, type = "trace")
```

A stationary log-likelihood trace with no visible trend or drift is a
first-pass convergence check.
For formal diagnostics see the **Models and Workflow** vignette.

## Adding DPM Flexibility

The Normal prior assumes latent abilities follow a Gaussian distribution.
When that assumption is questionable --- bimodal populations, floor/ceiling
effects, skew --- a Dirichlet Process Mixture (DPM) prior lets the data
speak.

```r
# This is the code you would run:
fit_dpm <- dpmirt(
  sim$response,
  model   = "rasch",
  prior   = "dpm",
  niter   = 10000,
  nburnin = 2000,
  seed    = 200
)
```

Again, we load a pre-computed result:

```{r load-fit-dpm, eval = has_data}
fit_dpm <- readRDS(find_extdata("vignette_fit_rasch_dpm.rds"))
```

### Posterior Density Comparison

```{r plot-dpm-density, eval = has_data, fig.cap = "Posterior mean theta density under the DPM prior."}
plot(fit_dpm, type = "density")
```

The overlay below places both posteriors on the same axes for a direct
comparison.  Because the true latent distribution here is Normal, the two
densities are nearly identical --- the DPM prior adapts to the data and
does not distort the estimates.

```{r density-overlay, eval = has_data, fig.cap = "Normal-prior vs. DPM-prior posterior mean densities on the same data.  When the true distribution is Normal, both priors recover it equally well."}
if (requireNamespace("ggplot2", quietly = TRUE)) {
  library(ggplot2)
  pm_normal <- colMeans(fit$theta_samp)
  pm_dpm    <- colMeans(fit_dpm$theta_samp)

  df_overlay <- data.frame(
    value  = c(pm_normal, pm_dpm),
    Prior  = factor(rep(c("Normal", "DPM"), each = length(pm_normal)),
                    levels = c("Normal", "DPM"))
  )

  ggplot(df_overlay, aes(x = value, colour = Prior, fill = Prior)) +
    geom_density(alpha = 0.25, linewidth = 0.9) +
    scale_colour_manual(values = c(Normal = pal$parametric,
                                    DPM   = pal$semiparametric)) +
    scale_fill_manual(values = c(Normal = pal$parametric,
                                  DPM   = pal$semiparametric)) +
    labs(title = "Normal vs. DPM Prior (Normal Population)",
         x = expression(theta), y = "Density") +
    theme_bw() +
    theme(legend.position = "top")
}
```

### Cluster Diagnostics

```{r plot-clusters, eval = has_data, fig.height = 4, fig.cap = "Number of active clusters across MCMC iterations (left) and its posterior distribution (right)."}
plot(fit_dpm, type = "clusters")
```

The left panel traces the number of active clusters at each post-burn-in
iteration; the right panel shows the posterior distribution of cluster
counts.
A single dominant mode suggests the data are well-described by that many
latent subgroups.

### DP Mixture Density

```{r plot-dp-density, eval = has_data, fig.cap = "DP mixture posterior mean density with 95 percent pointwise credible band. Dashed line: N(0,1) reference."}
plot(fit_dpm, type = "dp_density")
```

The solid curve is the posterior mean of the DP mixture density evaluated
on a fine grid; the shaded ribbon is a 95% pointwise credible band.
The dashed line shows the standard Normal for reference.

## Seeing the DPM Advantage

The example above used a truly Normal population, so both priors performed
equally well.  But what happens when the population departs from normality?
The DPMirt package ships with pre-computed results for a **bimodal**
population --- a 50/50 mixture of two groups centered at $\theta = -1.5$
and $\theta = 1.5$ --- that reveals the DPM prior's key advantage.

```{r bimodal-guard, include = FALSE}
has_bimodal_data <- nzchar(find_extdata("vignette_sim_bimodal.rds")) &&
  nzchar(find_extdata("vignette_fit_rasch_normal_bimodal.rds")) &&
  nzchar(find_extdata("vignette_fit_rasch_dpm_bimodal.rds"))
```

```{r bimodal-comparison, eval = has_bimodal_data, fig.height = 5, fig.cap = "When the true population is bimodal, the Normal prior forces a unimodal fit (blue), masking the two-group structure.  The DPM prior (orange) recovers both modes."}
sim_bm   <- readRDS(find_extdata("vignette_sim_bimodal.rds"))
fit_n_bm <- readRDS(find_extdata("vignette_fit_rasch_normal_bimodal.rds"))
fit_d_bm <- readRDS(find_extdata("vignette_fit_rasch_dpm_bimodal.rds"))

if (requireNamespace("ggplot2", quietly = TRUE)) {
  true_theta <- sim_bm$theta
  pm_normal  <- colMeans(fit_n_bm$theta_samp)
  pm_dpm     <- colMeans(fit_d_bm$theta_samp)

  df_bm <- data.frame(
    value  = c(true_theta, pm_normal, pm_dpm),
    source = factor(rep(c("True", "Normal Prior (PM)", "DPM Prior (PM)"),
                        each = length(true_theta)),
                    levels = c("True", "Normal Prior (PM)", "DPM Prior (PM)"))
  )

  ggplot(df_bm, aes(x = value, fill = source, colour = source)) +
    geom_density(alpha = 0.30, linewidth = 0.8) +
    scale_fill_manual(values = c("True"              = pal$reference,
                                  "Normal Prior (PM)" = pal$parametric,
                                  "DPM Prior (PM)"    = pal$semiparametric)) +
    scale_colour_manual(values = c("True"              = pal$reference,
                                    "Normal Prior (PM)" = pal$parametric,
                                    "DPM Prior (PM)"    = pal$semiparametric)) +
    labs(title = "Normal vs. DPM Prior: Recovering a Bimodal Population",
         subtitle = "Rasch model, 25 items, 200 persons",
         x = expression(theta), y = "Density") +
    theme_bw() +
    theme(legend.position = "bottom", legend.title = element_blank())
}
```

> **Key insight.** The Normal prior has no mechanism to represent two modes,
> so it forces all estimates toward a single central peak.  The DPM prior
> adapts its shape to the data, preserving the bimodal structure.  This
> difference is most consequential for classification decisions (e.g.,
> identifying students for intervention) and for reporting on the shape of
> the population distribution.  See `vignette("posterior-summaries")` for
> a detailed comparison of estimators that exploit this flexibility.

## Extracting Estimates

`dpmirt_estimates()` computes person and item point estimates using
three complementary posterior summary methods:

| Method | Full name | Optimizes |
|:------:|:----------|:----------|
| **PM** | Posterior Mean | Individual MSE (Goal 1) |
| **CB** | Constrained Bayes (Ghosh, 1992) | EDF estimation (Goal 3) |
| **GR** | Triple-Goal (Shen & Louis, 1998) | Ranking + EDF (Goals 2 & 3) |

```{r estimates, eval = has_data}
est <- dpmirt_estimates(fit_dpm, methods = c("pm", "cb", "gr"))
```

The `theta` element is a data frame with one row per person:

```{r estimates-table, eval = has_data}
head(est$theta, 10)
```

> **Which estimator should you use?**
> It depends on your inferential goal.
> If you need the best point prediction for each individual, use **PM**.
> If you need the set of estimates to reproduce the shape of the ability
> distribution (e.g., for group-level reporting), use **CB**.
> If you need both accurate rankings *and* distributional fidelity, use
> **GR**.
> See the **Posterior Summaries** vignette for an in-depth comparison.

Item estimates are available in `est$beta`:

```{r item-estimates, eval = has_data}
head(est$beta, 10)
```

## What's Next?

You now have a working end-to-end pipeline.
Depending on your goal, the following vignettes go deeper:

| Step | What to read | Why |
|:-----|:-------------|:----|
| Understand models | *Models and Workflow* | Step-by-step control over specification, compilation, and sampling; 2PL and 3PL models |
| Choose an estimator | *Posterior Summaries* | When PM vs CB vs GR; shrinkage diagnostics and loss evaluation |
| Set DPM priors | *Prior Elicitation* | Principled choice of the concentration parameter $\alpha$ via **DPprior** |

---

**Happy modeling!** You are now equipped to fit your own Rasch models with both parametric (Normal) and semiparametric (DPM) priors.
For questions, bugs, or suggestions, visit the [DPMirt repository](https://github.com/joonho112/DPMirt).
